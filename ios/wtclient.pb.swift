// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: wtclientrpc/wtclient.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Wtclientrpc_PolicyType: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Selects the policy from the legacy tower client.
  case legacy // = 0

  /// Selects the policy from the anchor tower client.
  case anchor // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .legacy
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .legacy
    case 1: self = .anchor
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .legacy: return 0
    case .anchor: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Wtclientrpc_PolicyType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Wtclientrpc_PolicyType] = [
    .legacy,
    .anchor,
  ]
}

#endif  // swift(>=4.2)

struct Wtclientrpc_AddTowerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifying public key of the watchtower to add.
  var pubkey: Data = Data()

  /// A network address the watchtower is reachable over.
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_AddTowerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_RemoveTowerRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifying public key of the watchtower to remove.
  var pubkey: Data = Data()

  ///
  ///If set, then the record for this address will be removed, indicating that is
  ///is stale. Otherwise, the watchtower will no longer be used for future
  ///session negotiations and backups.
  var address: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_RemoveTowerResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_GetTowerInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifying public key of the watchtower to retrieve information for.
  var pubkey: Data = Data()

  /// Whether we should include sessions with the watchtower in the response.
  var includeSessions: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_TowerSession {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The total number of successful backups that have been made to the
  ///watchtower session.
  var numBackups: UInt32 = 0

  ///
  ///The total number of backups in the session that are currently pending to be
  ///acknowledged by the watchtower.
  var numPendingBackups: UInt32 = 0

  /// The maximum number of backups allowed by the watchtower session.
  var maxBackups: UInt32 = 0

  ///
  ///The fee rate, in satoshis per vbyte, that will be used by the watchtower for
  ///the justice transaction in the event of a channel breach.
  var sweepSatPerByte: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_Tower {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identifying public key of the watchtower.
  var pubkey: Data = Data()

  /// The list of addresses the watchtower is reachable over.
  var addresses: [String] = []

  /// Whether the watchtower is currently a candidate for new sessions.
  var activeSessionCandidate: Bool = false

  /// The number of sessions that have been negotiated with the watchtower.
  var numSessions: UInt32 = 0

  /// The list of sessions that have been negotiated with the watchtower.
  var sessions: [Wtclientrpc_TowerSession] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_ListTowersRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether we should include sessions with the watchtower in the response.
  var includeSessions: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_ListTowersResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of watchtowers available for new backups.
  var towers: [Wtclientrpc_Tower] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_StatsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_StatsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The total number of backups made to all active and exhausted watchtower
  ///sessions.
  var numBackups: UInt32 = 0

  ///
  ///The total number of backups that are pending to be acknowledged by all
  ///active and exhausted watchtower sessions.
  var numPendingBackups: UInt32 = 0

  ///
  ///The total number of backups that all active and exhausted watchtower
  ///sessions have failed to acknowledge.
  var numFailedBackups: UInt32 = 0

  /// The total number of new sessions made to watchtowers.
  var numSessionsAcquired: UInt32 = 0

  /// The total number of watchtower sessions that have been exhausted.
  var numSessionsExhausted: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_PolicyRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The client type from which to retrieve the active offering policy.
  var policyType: Wtclientrpc_PolicyType = .legacy

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Wtclientrpc_PolicyResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The maximum number of updates each session we negotiate with watchtowers
  ///should allow.
  var maxUpdates: UInt32 = 0

  ///
  ///The fee rate, in satoshis per vbyte, that will be used by watchtowers for
  ///justice transactions in response to channel breaches.
  var sweepSatPerByte: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "wtclientrpc"

extension Wtclientrpc_PolicyType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "LEGACY"),
    1: .same(proto: "ANCHOR"),
  ]
}

extension Wtclientrpc_AddTowerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddTowerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pubkey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_AddTowerRequest, rhs: Wtclientrpc_AddTowerRequest) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_AddTowerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddTowerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_AddTowerResponse, rhs: Wtclientrpc_AddTowerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_RemoveTowerRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveTowerRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pubkey) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.address) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_RemoveTowerRequest, rhs: Wtclientrpc_RemoveTowerRequest) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_RemoveTowerResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RemoveTowerResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_RemoveTowerResponse, rhs: Wtclientrpc_RemoveTowerResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_GetTowerInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GetTowerInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .standard(proto: "include_sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pubkey) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.includeSessions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 1)
    }
    if self.includeSessions != false {
      try visitor.visitSingularBoolField(value: self.includeSessions, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_GetTowerInfoRequest, rhs: Wtclientrpc_GetTowerInfoRequest) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.includeSessions != rhs.includeSessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_TowerSession: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TowerSession"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_backups"),
    2: .standard(proto: "num_pending_backups"),
    3: .standard(proto: "max_backups"),
    4: .standard(proto: "sweep_sat_per_byte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numBackups) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numPendingBackups) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.maxBackups) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.sweepSatPerByte) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.numBackups, fieldNumber: 1)
    }
    if self.numPendingBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPendingBackups, fieldNumber: 2)
    }
    if self.maxBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxBackups, fieldNumber: 3)
    }
    if self.sweepSatPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.sweepSatPerByte, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_TowerSession, rhs: Wtclientrpc_TowerSession) -> Bool {
    if lhs.numBackups != rhs.numBackups {return false}
    if lhs.numPendingBackups != rhs.numPendingBackups {return false}
    if lhs.maxBackups != rhs.maxBackups {return false}
    if lhs.sweepSatPerByte != rhs.sweepSatPerByte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_Tower: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Tower"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "pubkey"),
    2: .same(proto: "addresses"),
    3: .standard(proto: "active_session_candidate"),
    4: .standard(proto: "num_sessions"),
    5: .same(proto: "sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.pubkey) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.addresses) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.activeSessionCandidate) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numSessions) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.sessions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 1)
    }
    if !self.addresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.addresses, fieldNumber: 2)
    }
    if self.activeSessionCandidate != false {
      try visitor.visitSingularBoolField(value: self.activeSessionCandidate, fieldNumber: 3)
    }
    if self.numSessions != 0 {
      try visitor.visitSingularUInt32Field(value: self.numSessions, fieldNumber: 4)
    }
    if !self.sessions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.sessions, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_Tower, rhs: Wtclientrpc_Tower) -> Bool {
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs.addresses != rhs.addresses {return false}
    if lhs.activeSessionCandidate != rhs.activeSessionCandidate {return false}
    if lhs.numSessions != rhs.numSessions {return false}
    if lhs.sessions != rhs.sessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_ListTowersRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTowersRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "include_sessions"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.includeSessions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.includeSessions != false {
      try visitor.visitSingularBoolField(value: self.includeSessions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_ListTowersRequest, rhs: Wtclientrpc_ListTowersRequest) -> Bool {
    if lhs.includeSessions != rhs.includeSessions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_ListTowersResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListTowersResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "towers"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.towers) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.towers.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.towers, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_ListTowersResponse, rhs: Wtclientrpc_ListTowersResponse) -> Bool {
    if lhs.towers != rhs.towers {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_StatsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_StatsRequest, rhs: Wtclientrpc_StatsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_StatsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StatsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "num_backups"),
    2: .standard(proto: "num_pending_backups"),
    3: .standard(proto: "num_failed_backups"),
    4: .standard(proto: "num_sessions_acquired"),
    5: .standard(proto: "num_sessions_exhausted"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.numBackups) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.numPendingBackups) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.numFailedBackups) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.numSessionsAcquired) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.numSessionsExhausted) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.numBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.numBackups, fieldNumber: 1)
    }
    if self.numPendingBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.numPendingBackups, fieldNumber: 2)
    }
    if self.numFailedBackups != 0 {
      try visitor.visitSingularUInt32Field(value: self.numFailedBackups, fieldNumber: 3)
    }
    if self.numSessionsAcquired != 0 {
      try visitor.visitSingularUInt32Field(value: self.numSessionsAcquired, fieldNumber: 4)
    }
    if self.numSessionsExhausted != 0 {
      try visitor.visitSingularUInt32Field(value: self.numSessionsExhausted, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_StatsResponse, rhs: Wtclientrpc_StatsResponse) -> Bool {
    if lhs.numBackups != rhs.numBackups {return false}
    if lhs.numPendingBackups != rhs.numPendingBackups {return false}
    if lhs.numFailedBackups != rhs.numFailedBackups {return false}
    if lhs.numSessionsAcquired != rhs.numSessionsAcquired {return false}
    if lhs.numSessionsExhausted != rhs.numSessionsExhausted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_PolicyRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "policy_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.policyType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.policyType != .legacy {
      try visitor.visitSingularEnumField(value: self.policyType, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_PolicyRequest, rhs: Wtclientrpc_PolicyRequest) -> Bool {
    if lhs.policyType != rhs.policyType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Wtclientrpc_PolicyResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PolicyResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_updates"),
    2: .standard(proto: "sweep_sat_per_byte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.maxUpdates) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.sweepSatPerByte) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxUpdates != 0 {
      try visitor.visitSingularUInt32Field(value: self.maxUpdates, fieldNumber: 1)
    }
    if self.sweepSatPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.sweepSatPerByte, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Wtclientrpc_PolicyResponse, rhs: Wtclientrpc_PolicyResponse) -> Bool {
    if lhs.maxUpdates != rhs.maxUpdates {return false}
    if lhs.sweepSatPerByte != rhs.sweepSatPerByte {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
