// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: walletrpc/walletkit.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Walletrpc_WitnessType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknownWitness // = 0

  ///
  ///A witness that allows us to spend the output of a commitment transaction
  ///after a relative lock-time lockout.
  case commitmentTimeLock // = 1

  ///
  ///A witness that allows us to spend a settled no-delay output immediately on a
  ///counterparty's commitment transaction.
  case commitmentNoDelay // = 2

  ///
  ///A witness that allows us to sweep the settled output of a malicious
  ///counterparty's who broadcasts a revoked commitment transaction.
  case commitmentRevoke // = 3

  ///
  ///A witness that allows us to sweep an HTLC which we offered to the remote
  ///party in the case that they broadcast a revoked commitment state.
  case htlcOfferedRevoke // = 4

  ///
  ///A witness that allows us to sweep an HTLC output sent to us in the case that
  ///the remote party broadcasts a revoked commitment state.
  case htlcAcceptedRevoke // = 5

  ///
  ///A witness that allows us to sweep an HTLC output that we extended to a
  ///party, but was never fulfilled.  This HTLC output isn't directly on the
  ///commitment transaction, but is the result of a confirmed second-level HTLC
  ///transaction. As a result, we can only spend this after a CSV delay.
  case htlcOfferedTimeoutSecondLevel // = 6

  ///
  ///A witness that allows us to sweep an HTLC output that was offered to us, and
  ///for which we have a payment preimage. This HTLC output isn't directly on our
  ///commitment transaction, but is the result of confirmed second-level HTLC
  ///transaction. As a result, we can only spend this after a CSV delay.
  case htlcAcceptedSuccessSecondLevel // = 7

  ///
  ///A witness that allows us to sweep an HTLC that we offered to the remote
  ///party which lies in the commitment transaction of the remote party. We can
  ///spend this output after the absolute CLTV timeout of the HTLC as passed.
  case htlcOfferedRemoteTimeout // = 8

  ///
  ///A witness that allows us to sweep an HTLC that was offered to us by the
  ///remote party. We use this witness in the case that the remote party goes to
  ///chain, and we know the pre-image to the HTLC. We can sweep this without any
  ///additional timeout.
  case htlcAcceptedRemoteSuccess // = 9

  ///
  ///A witness that allows us to sweep an HTLC from the remote party's commitment
  ///transaction in the case that the broadcast a revoked commitment, but then
  ///also immediately attempt to go to the second level to claim the HTLC.
  case htlcSecondLevelRevoke // = 10

  ///
  ///A witness type that allows us to spend a regular p2wkh output that's sent to
  ///an output which is under complete control of the backing wallet.
  case witnessKeyHash // = 11

  ///
  ///A witness type that allows us to sweep an output that sends to a nested P2SH
  ///script that pays to a key solely under our control.
  case nestedWitnessKeyHash // = 12

  ///
  ///A witness type that allows us to spend our anchor on the commitment
  ///transaction.
  case commitmentAnchor // = 13
  case UNRECOGNIZED(Int)

  init() {
    self = .unknownWitness
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknownWitness
    case 1: self = .commitmentTimeLock
    case 2: self = .commitmentNoDelay
    case 3: self = .commitmentRevoke
    case 4: self = .htlcOfferedRevoke
    case 5: self = .htlcAcceptedRevoke
    case 6: self = .htlcOfferedTimeoutSecondLevel
    case 7: self = .htlcAcceptedSuccessSecondLevel
    case 8: self = .htlcOfferedRemoteTimeout
    case 9: self = .htlcAcceptedRemoteSuccess
    case 10: self = .htlcSecondLevelRevoke
    case 11: self = .witnessKeyHash
    case 12: self = .nestedWitnessKeyHash
    case 13: self = .commitmentAnchor
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknownWitness: return 0
    case .commitmentTimeLock: return 1
    case .commitmentNoDelay: return 2
    case .commitmentRevoke: return 3
    case .htlcOfferedRevoke: return 4
    case .htlcAcceptedRevoke: return 5
    case .htlcOfferedTimeoutSecondLevel: return 6
    case .htlcAcceptedSuccessSecondLevel: return 7
    case .htlcOfferedRemoteTimeout: return 8
    case .htlcAcceptedRemoteSuccess: return 9
    case .htlcSecondLevelRevoke: return 10
    case .witnessKeyHash: return 11
    case .nestedWitnessKeyHash: return 12
    case .commitmentAnchor: return 13
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Walletrpc_WitnessType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Walletrpc_WitnessType] = [
    .unknownWitness,
    .commitmentTimeLock,
    .commitmentNoDelay,
    .commitmentRevoke,
    .htlcOfferedRevoke,
    .htlcAcceptedRevoke,
    .htlcOfferedTimeoutSecondLevel,
    .htlcAcceptedSuccessSecondLevel,
    .htlcOfferedRemoteTimeout,
    .htlcAcceptedRemoteSuccess,
    .htlcSecondLevelRevoke,
    .witnessKeyHash,
    .nestedWitnessKeyHash,
    .commitmentAnchor,
  ]
}

#endif  // swift(>=4.2)

struct Walletrpc_ListUnspentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The minimum number of confirmations to be included.
  var minConfs: Int32 = 0

  /// The maximum number of confirmations to be included.
  var maxConfs: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListUnspentResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// A list of utxos satisfying the specified number of confirmations.
  var utxos: [Lnrpc_Utxo] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_LeaseOutputRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///An ID of 32 random bytes that must be unique for each distinct application
  ///using this RPC which will be used to bound the output lease to.
  var id: Data = Data()

  /// The identifying outpoint of the output being leased.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_LeaseOutputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The absolute expiration of the output lease represented as a unix timestamp.
  var expiration: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ReleaseOutputRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The unique ID that was used to lock the output.
  var id: Data = Data()

  /// The identifying outpoint of the output being released.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_ReleaseOutputResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_KeyReq {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Is the key finger print of the root pubkey that this request is targeting.
  ///This allows the WalletKit to possibly serve out keys for multiple HD chains
  ///via public derivation.
  var keyFingerPrint: Int32 = 0

  ///
  ///The target key family to derive a key from. In other contexts, this is
  ///known as the "account".
  var keyFamily: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// No fields, as we always give out a p2wkh address.
struct Walletrpc_AddrRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_AddrResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The address encoded using a bech32 format.
  var addr: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_Transaction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The raw serialized transaction.
  var txHex: Data = Data()

  ///
  ///An optional label to save with the transaction. Limited to 500 characters.
  var label: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PublishResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///If blank, then no error occurred and the transaction was successfully
  ///published. If not the empty string, then a string representation of the
  ///broadcast error.
  ///
  ///TODO(roasbeef): map to a proper enum type
  var publishError: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SendOutputsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The number of satoshis per kilo weight that should be used when crafting
  ///this transaction.
  var satPerKw: Int64 = 0

  ///
  ///A slice of the outputs that should be created in the transaction produced.
  var outputs: [Signrpc_TxOut] = []

  /// An optional label for the transaction, limited to 500 characters.
  var label: String = String()

  /// The minimum number of confirmations each one of your outputs used for
  /// the transaction must satisfy.
  var minConfs: Int32 = 0

  /// Whether unconfirmed outputs should be used as inputs for the transaction.
  var spendUnconfirmed: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_SendOutputsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The serialized transaction sent out on the network.
  var rawTx: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_EstimateFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The number of confirmations to shoot for when estimating the fee.
  var confTarget: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_EstimateFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The amount of satoshis per kw that should be used in order to reach the
  ///confirmation target in the request.
  var satPerKw: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PendingSweep {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The outpoint of the output we're attempting to sweep.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The witness type of the output we're attempting to sweep.
  var witnessType: Walletrpc_WitnessType = .unknownWitness

  /// The value of the output we're attempting to sweep.
  var amountSat: UInt32 = 0

  ///
  ///The fee rate we'll use to sweep the output. The fee rate is only determined
  ///once a sweeping transaction for the output is created, so it's possible for
  ///this to be 0 before this.
  var satPerByte: UInt32 = 0

  /// The number of broadcast attempts we've made to sweep the output.
  var broadcastAttempts: UInt32 = 0

  ///
  ///The next height of the chain at which we'll attempt to broadcast the
  ///sweep transaction of the output.
  var nextBroadcastHeight: UInt32 = 0

  /// The requested confirmation target for this output.
  var requestedConfTarget: UInt32 = 0

  /// The requested fee rate, expressed in sat/byte, for this output.
  var requestedSatPerByte: UInt32 = 0

  ///
  ///Whether this input must be force-swept. This means that it is swept even
  ///if it has a negative yield.
  var force: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_PendingSweepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_PendingSweepsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The set of outputs currently being swept by lnd's central batching engine.
  var pendingSweeps: [Walletrpc_PendingSweep] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_BumpFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The input we're attempting to bump the fee of.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  /// The target number of blocks that the input should be spent within.
  var targetConf: UInt32 = 0

  ///
  ///The fee rate, expressed in sat/byte, that should be used to spend the input
  ///with.
  var satPerByte: UInt32 = 0

  ///
  ///Whether this input must be force-swept. This means that it is swept even
  ///if it has a negative yield.
  var force: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_BumpFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListSweepsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Retrieve the full sweep transaction details. If false, only the sweep txids
  ///will be returned. Note that some sweeps that LND publishes will have been
  ///replaced-by-fee, so will not be included in this output.
  var verbose: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_ListSweepsResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sweeps: Walletrpc_ListSweepsResponse.OneOf_Sweeps? = nil

  var transactionDetails: Lnrpc_TransactionDetails {
    get {
      if case .transactionDetails(let v)? = sweeps {return v}
      return Lnrpc_TransactionDetails()
    }
    set {sweeps = .transactionDetails(newValue)}
  }

  var transactionIds: Walletrpc_ListSweepsResponse.TransactionIDs {
    get {
      if case .transactionIds(let v)? = sweeps {return v}
      return Walletrpc_ListSweepsResponse.TransactionIDs()
    }
    set {sweeps = .transactionIds(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Sweeps: Equatable {
    case transactionDetails(Lnrpc_TransactionDetails)
    case transactionIds(Walletrpc_ListSweepsResponse.TransactionIDs)

  #if !swift(>=4.1)
    static func ==(lhs: Walletrpc_ListSweepsResponse.OneOf_Sweeps, rhs: Walletrpc_ListSweepsResponse.OneOf_Sweeps) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.transactionDetails, .transactionDetails): return {
        guard case .transactionDetails(let l) = lhs, case .transactionDetails(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.transactionIds, .transactionIds): return {
        guard case .transactionIds(let l) = lhs, case .transactionIds(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  struct TransactionIDs {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    ///
    ///Reversed, hex-encoded string representing the transaction ids of the
    ///sweeps that our node has broadcast. Note that these transactions may
    ///not have confirmed yet, we record sweeps on broadcast, not confirmation.
    var transactionIds: [String] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct Walletrpc_LabelTransactionRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The txid of the transaction to label.
  var txid: Data = Data()

  /// The label to add to the transaction, limited to 500 characters.
  var label: String = String()

  /// Whether to overwrite the existing label, if it is present.
  var overwrite: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_LabelTransactionResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_FundPsbtRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var template: Walletrpc_FundPsbtRequest.OneOf_Template? = nil

  ///
  ///Use an existing PSBT packet as the template for the funded PSBT.
  ///
  ///The packet must contain at least one non-dust output. If one or more
  ///inputs are specified, no coin selection is performed. In that case every
  ///input must be an UTXO known to the wallet that has not been locked
  ///before. The sum of all inputs must be sufficiently greater than the sum
  ///of all outputs to pay a miner fee with the specified fee rate. A change
  ///output is added to the PSBT if necessary.
  var psbt: Data {
    get {
      if case .psbt(let v)? = template {return v}
      return Data()
    }
    set {template = .psbt(newValue)}
  }

  ///
  ///Use the outputs and optional inputs from this raw template.
  var raw: Walletrpc_TxTemplate {
    get {
      if case .raw(let v)? = template {return v}
      return Walletrpc_TxTemplate()
    }
    set {template = .raw(newValue)}
  }

  var fees: Walletrpc_FundPsbtRequest.OneOf_Fees? = nil

  ///
  ///The target number of blocks that the transaction should be confirmed in.
  var targetConf: UInt32 {
    get {
      if case .targetConf(let v)? = fees {return v}
      return 0
    }
    set {fees = .targetConf(newValue)}
  }

  ///
  ///The fee rate, expressed in sat/vbyte, that should be used to spend the
  ///input with.
  var satPerVbyte: UInt32 {
    get {
      if case .satPerVbyte(let v)? = fees {return v}
      return 0
    }
    set {fees = .satPerVbyte(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Template: Equatable {
    ///
    ///Use an existing PSBT packet as the template for the funded PSBT.
    ///
    ///The packet must contain at least one non-dust output. If one or more
    ///inputs are specified, no coin selection is performed. In that case every
    ///input must be an UTXO known to the wallet that has not been locked
    ///before. The sum of all inputs must be sufficiently greater than the sum
    ///of all outputs to pay a miner fee with the specified fee rate. A change
    ///output is added to the PSBT if necessary.
    case psbt(Data)
    ///
    ///Use the outputs and optional inputs from this raw template.
    case raw(Walletrpc_TxTemplate)

  #if !swift(>=4.1)
    static func ==(lhs: Walletrpc_FundPsbtRequest.OneOf_Template, rhs: Walletrpc_FundPsbtRequest.OneOf_Template) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.psbt, .psbt): return {
        guard case .psbt(let l) = lhs, case .psbt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.raw, .raw): return {
        guard case .raw(let l) = lhs, case .raw(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum OneOf_Fees: Equatable {
    ///
    ///The target number of blocks that the transaction should be confirmed in.
    case targetConf(UInt32)
    ///
    ///The fee rate, expressed in sat/vbyte, that should be used to spend the
    ///input with.
    case satPerVbyte(UInt32)

  #if !swift(>=4.1)
    static func ==(lhs: Walletrpc_FundPsbtRequest.OneOf_Fees, rhs: Walletrpc_FundPsbtRequest.OneOf_Fees) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.targetConf, .targetConf): return {
        guard case .targetConf(let l) = lhs, case .targetConf(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.satPerVbyte, .satPerVbyte): return {
        guard case .satPerVbyte(let l) = lhs, case .satPerVbyte(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Walletrpc_FundPsbtResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The funded but not yet signed PSBT packet.
  var fundedPsbt: Data = Data()

  ///
  ///The index of the added change output or -1 if no change was left over.
  var changeOutputIndex: Int32 = 0

  ///
  ///The list of lock leases that were acquired for the inputs in the funded PSBT
  ///packet.
  var lockedUtxos: [Walletrpc_UtxoLease] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_TxTemplate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///An optional list of inputs to use. Every input must be an UTXO known to the
  ///wallet that has not been locked before. The sum of all inputs must be
  ///sufficiently greater than the sum of all outputs to pay a miner fee with the
  ///fee rate specified in the parent message.
  ///
  ///If no inputs are specified, coin selection will be performed instead and
  ///inputs of sufficient value will be added to the resulting PSBT.
  var inputs: [Lnrpc_OutPoint] = []

  ///
  ///A map of all addresses and the amounts to send to in the funded PSBT.
  var outputs: Dictionary<String,UInt64> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_UtxoLease {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A 32 byte random ID that identifies the lease.
  var id: Data = Data()

  /// The identifying outpoint of the output being leased.
  var outpoint: Lnrpc_OutPoint {
    get {return _outpoint ?? Lnrpc_OutPoint()}
    set {_outpoint = newValue}
  }
  /// Returns true if `outpoint` has been explicitly set.
  var hasOutpoint: Bool {return self._outpoint != nil}
  /// Clears the value of `outpoint`. Subsequent reads from it will return its default value.
  mutating func clearOutpoint() {self._outpoint = nil}

  ///
  ///The absolute expiration of the output lease represented as a unix timestamp.
  var expiration: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _outpoint: Lnrpc_OutPoint? = nil
}

struct Walletrpc_FinalizePsbtRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A PSBT that should be signed and finalized. The PSBT must contain all
  ///required inputs, outputs, UTXO data and partial signatures of all other
  ///signers.
  var fundedPsbt: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Walletrpc_FinalizePsbtResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The fully signed and finalized transaction in PSBT format.
  var signedPsbt: Data = Data()

  /// The fully signed and finalized transaction in the raw wire format.
  var rawFinalTx: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "walletrpc"

extension Walletrpc_WitnessType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN_WITNESS"),
    1: .same(proto: "COMMITMENT_TIME_LOCK"),
    2: .same(proto: "COMMITMENT_NO_DELAY"),
    3: .same(proto: "COMMITMENT_REVOKE"),
    4: .same(proto: "HTLC_OFFERED_REVOKE"),
    5: .same(proto: "HTLC_ACCEPTED_REVOKE"),
    6: .same(proto: "HTLC_OFFERED_TIMEOUT_SECOND_LEVEL"),
    7: .same(proto: "HTLC_ACCEPTED_SUCCESS_SECOND_LEVEL"),
    8: .same(proto: "HTLC_OFFERED_REMOTE_TIMEOUT"),
    9: .same(proto: "HTLC_ACCEPTED_REMOTE_SUCCESS"),
    10: .same(proto: "HTLC_SECOND_LEVEL_REVOKE"),
    11: .same(proto: "WITNESS_KEY_HASH"),
    12: .same(proto: "NESTED_WITNESS_KEY_HASH"),
    13: .same(proto: "COMMITMENT_ANCHOR"),
  ]
}

extension Walletrpc_ListUnspentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "min_confs"),
    2: .standard(proto: "max_confs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.maxConfs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 1)
    }
    if self.maxConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.maxConfs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListUnspentRequest, rhs: Walletrpc_ListUnspentRequest) -> Bool {
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.maxConfs != rhs.maxConfs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListUnspentResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListUnspentResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.utxos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.utxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.utxos, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListUnspentResponse, rhs: Walletrpc_ListUnspentResponse) -> Bool {
    if lhs.utxos != rhs.utxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LeaseOutputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaseOutputRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LeaseOutputRequest, rhs: Walletrpc_LeaseOutputRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LeaseOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeaseOutputResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "expiration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.expiration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.expiration != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiration, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LeaseOutputResponse, rhs: Walletrpc_LeaseOutputResponse) -> Bool {
    if lhs.expiration != rhs.expiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ReleaseOutputRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseOutputRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ReleaseOutputRequest, rhs: Walletrpc_ReleaseOutputRequest) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ReleaseOutputResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReleaseOutputResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ReleaseOutputResponse, rhs: Walletrpc_ReleaseOutputResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_KeyReq: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".KeyReq"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_finger_print"),
    2: .standard(proto: "key_family"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.keyFingerPrint) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.keyFamily) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.keyFingerPrint != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFingerPrint, fieldNumber: 1)
    }
    if self.keyFamily != 0 {
      try visitor.visitSingularInt32Field(value: self.keyFamily, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_KeyReq, rhs: Walletrpc_KeyReq) -> Bool {
    if lhs.keyFingerPrint != rhs.keyFingerPrint {return false}
    if lhs.keyFamily != rhs.keyFamily {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddrRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddrRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddrRequest, rhs: Walletrpc_AddrRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_AddrResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AddrResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.addr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.addr.isEmpty {
      try visitor.visitSingularStringField(value: self.addr, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_AddrResponse, rhs: Walletrpc_AddrResponse) -> Bool {
    if lhs.addr != rhs.addr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_Transaction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Transaction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tx_hex"),
    2: .same(proto: "label"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txHex) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txHex.isEmpty {
      try visitor.visitSingularBytesField(value: self.txHex, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_Transaction, rhs: Walletrpc_Transaction) -> Bool {
    if lhs.txHex != rhs.txHex {return false}
    if lhs.label != rhs.label {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PublishResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PublishResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "publish_error"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.publishError) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.publishError.isEmpty {
      try visitor.visitSingularStringField(value: self.publishError, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PublishResponse, rhs: Walletrpc_PublishResponse) -> Bool {
    if lhs.publishError != rhs.publishError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SendOutputsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendOutputsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_kw"),
    2: .same(proto: "outputs"),
    3: .same(proto: "label"),
    4: .standard(proto: "min_confs"),
    5: .standard(proto: "spend_unconfirmed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.satPerKw) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.outputs) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.minConfs) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.spendUnconfirmed) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.satPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerKw, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 3)
    }
    if self.minConfs != 0 {
      try visitor.visitSingularInt32Field(value: self.minConfs, fieldNumber: 4)
    }
    if self.spendUnconfirmed != false {
      try visitor.visitSingularBoolField(value: self.spendUnconfirmed, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SendOutputsRequest, rhs: Walletrpc_SendOutputsRequest) -> Bool {
    if lhs.satPerKw != rhs.satPerKw {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.label != rhs.label {return false}
    if lhs.minConfs != rhs.minConfs {return false}
    if lhs.spendUnconfirmed != rhs.spendUnconfirmed {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_SendOutputsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendOutputsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "raw_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.rawTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.rawTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawTx, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_SendOutputsResponse, rhs: Walletrpc_SendOutputsResponse) -> Bool {
    if lhs.rawTx != rhs.rawTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_EstimateFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conf_target"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.confTarget) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.confTarget != 0 {
      try visitor.visitSingularInt32Field(value: self.confTarget, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_EstimateFeeRequest, rhs: Walletrpc_EstimateFeeRequest) -> Bool {
    if lhs.confTarget != rhs.confTarget {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_EstimateFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EstimateFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sat_per_kw"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.satPerKw) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.satPerKw != 0 {
      try visitor.visitSingularInt64Field(value: self.satPerKw, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_EstimateFeeResponse, rhs: Walletrpc_EstimateFeeResponse) -> Bool {
    if lhs.satPerKw != rhs.satPerKw {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweep: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweep"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "witness_type"),
    3: .standard(proto: "amount_sat"),
    4: .standard(proto: "sat_per_byte"),
    5: .standard(proto: "broadcast_attempts"),
    6: .standard(proto: "next_broadcast_height"),
    8: .standard(proto: "requested_conf_target"),
    9: .standard(proto: "requested_sat_per_byte"),
    7: .same(proto: "force"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.witnessType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.amountSat) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.satPerByte) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self.broadcastAttempts) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.nextBroadcastHeight) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      case 8: try { try decoder.decodeSingularUInt32Field(value: &self.requestedConfTarget) }()
      case 9: try { try decoder.decodeSingularUInt32Field(value: &self.requestedSatPerByte) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.witnessType != .unknownWitness {
      try visitor.visitSingularEnumField(value: self.witnessType, fieldNumber: 2)
    }
    if self.amountSat != 0 {
      try visitor.visitSingularUInt32Field(value: self.amountSat, fieldNumber: 3)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.satPerByte, fieldNumber: 4)
    }
    if self.broadcastAttempts != 0 {
      try visitor.visitSingularUInt32Field(value: self.broadcastAttempts, fieldNumber: 5)
    }
    if self.nextBroadcastHeight != 0 {
      try visitor.visitSingularUInt32Field(value: self.nextBroadcastHeight, fieldNumber: 6)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 7)
    }
    if self.requestedConfTarget != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestedConfTarget, fieldNumber: 8)
    }
    if self.requestedSatPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.requestedSatPerByte, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweep, rhs: Walletrpc_PendingSweep) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.witnessType != rhs.witnessType {return false}
    if lhs.amountSat != rhs.amountSat {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.broadcastAttempts != rhs.broadcastAttempts {return false}
    if lhs.nextBroadcastHeight != rhs.nextBroadcastHeight {return false}
    if lhs.requestedConfTarget != rhs.requestedConfTarget {return false}
    if lhs.requestedSatPerByte != rhs.requestedSatPerByte {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweepsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweepsRequest, rhs: Walletrpc_PendingSweepsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_PendingSweepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingSweepsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pending_sweeps"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.pendingSweeps) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pendingSweeps.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pendingSweeps, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_PendingSweepsResponse, rhs: Walletrpc_PendingSweepsResponse) -> Bool {
    if lhs.pendingSweeps != rhs.pendingSweeps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_BumpFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "outpoint"),
    2: .standard(proto: "target_conf"),
    3: .standard(proto: "sat_per_byte"),
    4: .same(proto: "force"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.targetConf) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self.satPerByte) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.force) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.targetConf != 0 {
      try visitor.visitSingularUInt32Field(value: self.targetConf, fieldNumber: 2)
    }
    if self.satPerByte != 0 {
      try visitor.visitSingularUInt32Field(value: self.satPerByte, fieldNumber: 3)
    }
    if self.force != false {
      try visitor.visitSingularBoolField(value: self.force, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_BumpFeeRequest, rhs: Walletrpc_BumpFeeRequest) -> Bool {
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.targetConf != rhs.targetConf {return false}
    if lhs.satPerByte != rhs.satPerByte {return false}
    if lhs.force != rhs.force {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_BumpFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BumpFeeResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_BumpFeeResponse, rhs: Walletrpc_BumpFeeResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSweepsRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "verbose"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.verbose) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.verbose != false {
      try visitor.visitSingularBoolField(value: self.verbose, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsRequest, rhs: Walletrpc_ListSweepsRequest) -> Bool {
    if lhs.verbose != rhs.verbose {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListSweepsResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_details"),
    2: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Lnrpc_TransactionDetails?
        if let current = self.sweeps {
          try decoder.handleConflictingOneOf()
          if case .transactionDetails(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sweeps = .transactionDetails(v)}
      }()
      case 2: try {
        var v: Walletrpc_ListSweepsResponse.TransactionIDs?
        if let current = self.sweeps {
          try decoder.handleConflictingOneOf()
          if case .transactionIds(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.sweeps = .transactionIds(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.sweeps {
    case .transactionDetails?: try {
      guard case .transactionDetails(let v)? = self.sweeps else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .transactionIds?: try {
      guard case .transactionIds(let v)? = self.sweeps else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsResponse, rhs: Walletrpc_ListSweepsResponse) -> Bool {
    if lhs.sweeps != rhs.sweeps {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_ListSweepsResponse.TransactionIDs: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Walletrpc_ListSweepsResponse.protoMessageName + ".TransactionIDs"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.transactionIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.transactionIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.transactionIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_ListSweepsResponse.TransactionIDs, rhs: Walletrpc_ListSweepsResponse.TransactionIDs) -> Bool {
    if lhs.transactionIds != rhs.transactionIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LabelTransactionRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelTransactionRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "txid"),
    2: .same(proto: "label"),
    3: .same(proto: "overwrite"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.txid) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.label) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.overwrite) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.txid.isEmpty {
      try visitor.visitSingularBytesField(value: self.txid, fieldNumber: 1)
    }
    if !self.label.isEmpty {
      try visitor.visitSingularStringField(value: self.label, fieldNumber: 2)
    }
    if self.overwrite != false {
      try visitor.visitSingularBoolField(value: self.overwrite, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LabelTransactionRequest, rhs: Walletrpc_LabelTransactionRequest) -> Bool {
    if lhs.txid != rhs.txid {return false}
    if lhs.label != rhs.label {return false}
    if lhs.overwrite != rhs.overwrite {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_LabelTransactionResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LabelTransactionResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_LabelTransactionResponse, rhs: Walletrpc_LabelTransactionResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FundPsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundPsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "psbt"),
    2: .same(proto: "raw"),
    3: .standard(proto: "target_conf"),
    4: .standard(proto: "sat_per_vbyte"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        if self.template != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.template = .psbt(v)}
      }()
      case 2: try {
        var v: Walletrpc_TxTemplate?
        if let current = self.template {
          try decoder.handleConflictingOneOf()
          if case .raw(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.template = .raw(v)}
      }()
      case 3: try {
        if self.fees != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.fees = .targetConf(v)}
      }()
      case 4: try {
        if self.fees != nil {try decoder.handleConflictingOneOf()}
        var v: UInt32?
        try decoder.decodeSingularUInt32Field(value: &v)
        if let v = v {self.fees = .satPerVbyte(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.template {
    case .psbt?: try {
      guard case .psbt(let v)? = self.template else { preconditionFailure() }
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    }()
    case .raw?: try {
      guard case .raw(let v)? = self.template else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.fees {
    case .targetConf?: try {
      guard case .targetConf(let v)? = self.fees else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    }()
    case .satPerVbyte?: try {
      guard case .satPerVbyte(let v)? = self.fees else { preconditionFailure() }
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FundPsbtRequest, rhs: Walletrpc_FundPsbtRequest) -> Bool {
    if lhs.template != rhs.template {return false}
    if lhs.fees != rhs.fees {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FundPsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FundPsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funded_psbt"),
    2: .standard(proto: "change_output_index"),
    3: .standard(proto: "locked_utxos"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fundedPsbt) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.changeOutputIndex) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.lockedUtxos) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundedPsbt, fieldNumber: 1)
    }
    if self.changeOutputIndex != 0 {
      try visitor.visitSingularInt32Field(value: self.changeOutputIndex, fieldNumber: 2)
    }
    if !self.lockedUtxos.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lockedUtxos, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FundPsbtResponse, rhs: Walletrpc_FundPsbtResponse) -> Bool {
    if lhs.fundedPsbt != rhs.fundedPsbt {return false}
    if lhs.changeOutputIndex != rhs.changeOutputIndex {return false}
    if lhs.lockedUtxos != rhs.lockedUtxos {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_TxTemplate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxTemplate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.inputs) }()
      case 2: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: &self.outputs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufUInt64>.self, value: self.outputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_TxTemplate, rhs: Walletrpc_TxTemplate) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_UtxoLease: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UtxoLease"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "outpoint"),
    3: .same(proto: "expiration"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._outpoint) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.expiration) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularBytesField(value: self.id, fieldNumber: 1)
    }
    if let v = self._outpoint {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.expiration != 0 {
      try visitor.visitSingularUInt64Field(value: self.expiration, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_UtxoLease, rhs: Walletrpc_UtxoLease) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._outpoint != rhs._outpoint {return false}
    if lhs.expiration != rhs.expiration {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FinalizePsbtRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizePsbtRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "funded_psbt"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fundedPsbt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fundedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.fundedPsbt, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FinalizePsbtRequest, rhs: Walletrpc_FinalizePsbtRequest) -> Bool {
    if lhs.fundedPsbt != rhs.fundedPsbt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Walletrpc_FinalizePsbtResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FinalizePsbtResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "signed_psbt"),
    2: .standard(proto: "raw_final_tx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.signedPsbt) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.rawFinalTx) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.signedPsbt.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedPsbt, fieldNumber: 1)
    }
    if !self.rawFinalTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.rawFinalTx, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Walletrpc_FinalizePsbtResponse, rhs: Walletrpc_FinalizePsbtResponse) -> Bool {
    if lhs.signedPsbt != rhs.signedPsbt {return false}
    if lhs.rawFinalTx != rhs.rawFinalTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
