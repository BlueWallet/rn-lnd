// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: routerrpc/router.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Routerrpc_FailureDetail: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case unknown // = 0
  case noDetail // = 1
  case onionDecode // = 2
  case linkNotEligible // = 3
  case onChainTimeout // = 4
  case htlcExceedsMax // = 5
  case insufficientBalance // = 6
  case incompleteForward // = 7
  case htlcAddFailed // = 8
  case forwardsDisabled // = 9
  case invoiceCanceled // = 10
  case invoiceUnderpaid // = 11
  case invoiceExpiryTooSoon // = 12
  case invoiceNotOpen // = 13
  case mppInvoiceTimeout // = 14
  case addressMismatch // = 15
  case setTotalMismatch // = 16
  case setTotalTooLow // = 17
  case setOverpaid // = 18
  case unknownInvoice // = 19
  case invalidKeysend // = 20
  case mppInProgress // = 21
  case circularRoute // = 22
  case UNRECOGNIZED(Int)

  init() {
    self = .unknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .noDetail
    case 2: self = .onionDecode
    case 3: self = .linkNotEligible
    case 4: self = .onChainTimeout
    case 5: self = .htlcExceedsMax
    case 6: self = .insufficientBalance
    case 7: self = .incompleteForward
    case 8: self = .htlcAddFailed
    case 9: self = .forwardsDisabled
    case 10: self = .invoiceCanceled
    case 11: self = .invoiceUnderpaid
    case 12: self = .invoiceExpiryTooSoon
    case 13: self = .invoiceNotOpen
    case 14: self = .mppInvoiceTimeout
    case 15: self = .addressMismatch
    case 16: self = .setTotalMismatch
    case 17: self = .setTotalTooLow
    case 18: self = .setOverpaid
    case 19: self = .unknownInvoice
    case 20: self = .invalidKeysend
    case 21: self = .mppInProgress
    case 22: self = .circularRoute
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .noDetail: return 1
    case .onionDecode: return 2
    case .linkNotEligible: return 3
    case .onChainTimeout: return 4
    case .htlcExceedsMax: return 5
    case .insufficientBalance: return 6
    case .incompleteForward: return 7
    case .htlcAddFailed: return 8
    case .forwardsDisabled: return 9
    case .invoiceCanceled: return 10
    case .invoiceUnderpaid: return 11
    case .invoiceExpiryTooSoon: return 12
    case .invoiceNotOpen: return 13
    case .mppInvoiceTimeout: return 14
    case .addressMismatch: return 15
    case .setTotalMismatch: return 16
    case .setTotalTooLow: return 17
    case .setOverpaid: return 18
    case .unknownInvoice: return 19
    case .invalidKeysend: return 20
    case .mppInProgress: return 21
    case .circularRoute: return 22
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Routerrpc_FailureDetail: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Routerrpc_FailureDetail] = [
    .unknown,
    .noDetail,
    .onionDecode,
    .linkNotEligible,
    .onChainTimeout,
    .htlcExceedsMax,
    .insufficientBalance,
    .incompleteForward,
    .htlcAddFailed,
    .forwardsDisabled,
    .invoiceCanceled,
    .invoiceUnderpaid,
    .invoiceExpiryTooSoon,
    .invoiceNotOpen,
    .mppInvoiceTimeout,
    .addressMismatch,
    .setTotalMismatch,
    .setTotalTooLow,
    .setOverpaid,
    .unknownInvoice,
    .invalidKeysend,
    .mppInProgress,
    .circularRoute,
  ]
}

#endif  // swift(>=4.2)

enum Routerrpc_PaymentState: SwiftProtobuf.Enum {
  typealias RawValue = Int

  ///
  ///Payment is still in flight.
  case inFlight // = 0

  ///
  ///Payment completed successfully.
  case succeeded // = 1

  ///
  ///There are more routes to try, but the payment timeout was exceeded.
  case failedTimeout // = 2

  ///
  ///All possible routes were tried and failed permanently. Or were no
  ///routes to the destination at all.
  case failedNoRoute // = 3

  ///
  ///A non-recoverable error has occured.
  case failedError // = 4

  ///
  ///Payment details incorrect (unknown hash, invalid amt or
  ///invalid final cltv delta)
  case failedIncorrectPaymentDetails // = 5

  ///
  ///Insufficient local balance.
  case failedInsufficientBalance // = 6
  case UNRECOGNIZED(Int)

  init() {
    self = .inFlight
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .inFlight
    case 1: self = .succeeded
    case 2: self = .failedTimeout
    case 3: self = .failedNoRoute
    case 4: self = .failedError
    case 5: self = .failedIncorrectPaymentDetails
    case 6: self = .failedInsufficientBalance
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .inFlight: return 0
    case .succeeded: return 1
    case .failedTimeout: return 2
    case .failedNoRoute: return 3
    case .failedError: return 4
    case .failedIncorrectPaymentDetails: return 5
    case .failedInsufficientBalance: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Routerrpc_PaymentState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Routerrpc_PaymentState] = [
    .inFlight,
    .succeeded,
    .failedTimeout,
    .failedNoRoute,
    .failedError,
    .failedIncorrectPaymentDetails,
    .failedInsufficientBalance,
  ]
}

#endif  // swift(>=4.2)

enum Routerrpc_ResolveHoldForwardAction: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case settle // = 0
  case fail // = 1
  case resume // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .settle
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .settle
    case 1: self = .fail
    case 2: self = .resume
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .settle: return 0
    case .fail: return 1
    case .resume: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Routerrpc_ResolveHoldForwardAction: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Routerrpc_ResolveHoldForwardAction] = [
    .settle,
    .fail,
    .resume,
  ]
}

#endif  // swift(>=4.2)

struct Routerrpc_SendPaymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The identity pubkey of the payment recipient
  var dest: Data {
    get {return _storage._dest}
    set {_uniqueStorage()._dest = newValue}
  }

  ///
  ///Number of satoshis to send.
  ///
  ///The fields amt and amt_msat are mutually exclusive.
  var amt: Int64 {
    get {return _storage._amt}
    set {_uniqueStorage()._amt = newValue}
  }

  ///
  ///Number of millisatoshis to send.
  ///
  ///The fields amt and amt_msat are mutually exclusive.
  var amtMsat: Int64 {
    get {return _storage._amtMsat}
    set {_uniqueStorage()._amtMsat = newValue}
  }

  /// The hash to use within the payment's HTLC
  var paymentHash: Data {
    get {return _storage._paymentHash}
    set {_uniqueStorage()._paymentHash = newValue}
  }

  ///
  ///The CLTV delta from the current height that should be used to set the
  ///timelock for the final hop.
  var finalCltvDelta: Int32 {
    get {return _storage._finalCltvDelta}
    set {_uniqueStorage()._finalCltvDelta = newValue}
  }

  /// An optional payment addr to be included within the last hop of the route.
  var paymentAddr: Data {
    get {return _storage._paymentAddr}
    set {_uniqueStorage()._paymentAddr = newValue}
  }

  ///
  ///A bare-bones invoice for a payment within the Lightning Network.  With the
  ///details of the invoice, the sender has all the data necessary to send a
  ///payment to the recipient. The amount in the payment request may be zero. In
  ///that case it is required to set the amt field as well. If no payment request
  ///is specified, the following fields are required: dest, amt and payment_hash.
  var paymentRequest: String {
    get {return _storage._paymentRequest}
    set {_uniqueStorage()._paymentRequest = newValue}
  }

  ///
  ///An upper limit on the amount of time we should spend when attempting to
  ///fulfill the payment. This is expressed in seconds. If we cannot make a
  ///successful payment within this time frame, an error will be returned.
  ///This field must be non-zero.
  var timeoutSeconds: Int32 {
    get {return _storage._timeoutSeconds}
    set {_uniqueStorage()._timeoutSeconds = newValue}
  }

  ///
  ///The maximum number of satoshis that will be paid as a fee of the payment.
  ///If this field is left to the default value of 0, only zero-fee routes will
  ///be considered. This usually means single hop routes connecting directly to
  ///the destination. To send the payment without a fee limit, use max int here.
  ///
  ///The fields fee_limit_sat and fee_limit_msat are mutually exclusive.
  var feeLimitSat: Int64 {
    get {return _storage._feeLimitSat}
    set {_uniqueStorage()._feeLimitSat = newValue}
  }

  ///
  ///The maximum number of millisatoshis that will be paid as a fee of the
  ///payment. If this field is left to the default value of 0, only zero-fee
  ///routes will be considered. This usually means single hop routes connecting
  ///directly to the destination. To send the payment without a fee limit, use
  ///max int here.
  ///
  ///The fields fee_limit_sat and fee_limit_msat are mutually exclusive.
  var feeLimitMsat: Int64 {
    get {return _storage._feeLimitMsat}
    set {_uniqueStorage()._feeLimitMsat = newValue}
  }

  ///
  ///Deprecated, use outgoing_chan_ids. The channel id of the channel that must
  ///be taken to the first hop. If zero, any channel may be used (unless
  ///outgoing_chan_ids are set).
  var outgoingChanID: UInt64 {
    get {return _storage._outgoingChanID}
    set {_uniqueStorage()._outgoingChanID = newValue}
  }

  ///
  ///The channel ids of the channels are allowed for the first hop. If empty,
  ///any channel may be used.
  var outgoingChanIds: [UInt64] {
    get {return _storage._outgoingChanIds}
    set {_uniqueStorage()._outgoingChanIds = newValue}
  }

  ///
  ///The pubkey of the last hop of the route. If empty, any hop may be used.
  var lastHopPubkey: Data {
    get {return _storage._lastHopPubkey}
    set {_uniqueStorage()._lastHopPubkey = newValue}
  }

  ///
  ///An optional maximum total time lock for the route. This should not exceed
  ///lnd's `--max-cltv-expiry` setting. If zero, then the value of
  ///`--max-cltv-expiry` is enforced.
  var cltvLimit: Int32 {
    get {return _storage._cltvLimit}
    set {_uniqueStorage()._cltvLimit = newValue}
  }

  ///
  ///Optional route hints to reach the destination through private channels.
  var routeHints: [Lnrpc_RouteHint] {
    get {return _storage._routeHints}
    set {_uniqueStorage()._routeHints = newValue}
  }

  ///
  ///An optional field that can be used to pass an arbitrary set of TLV records
  ///to a peer which understands the new records. This can be used to pass
  ///application specific data during the payment attempt. Record types are
  ///required to be in the custom range >= 65536. When using REST, the values
  ///must be encoded as base64.
  var destCustomRecords: Dictionary<UInt64,Data> {
    get {return _storage._destCustomRecords}
    set {_uniqueStorage()._destCustomRecords = newValue}
  }

  /// If set, circular payments to self are permitted.
  var allowSelfPayment: Bool {
    get {return _storage._allowSelfPayment}
    set {_uniqueStorage()._allowSelfPayment = newValue}
  }

  ///
  ///Features assumed to be supported by the final node. All transitive feature
  ///dependencies must also be set properly. For a given feature bit pair, either
  ///optional or remote may be set, but not both. If this field is nil or empty,
  ///the router will try to load destination features from the graph as a
  ///fallback.
  var destFeatures: [Lnrpc_FeatureBit] {
    get {return _storage._destFeatures}
    set {_uniqueStorage()._destFeatures = newValue}
  }

  ///
  ///The maximum number of partial payments that may be use to complete the full
  ///amount.
  var maxParts: UInt32 {
    get {return _storage._maxParts}
    set {_uniqueStorage()._maxParts = newValue}
  }

  ///
  ///If set, only the final payment update is streamed back. Intermediate updates
  ///that show which htlcs are still in flight are suppressed.
  var noInflightUpdates: Bool {
    get {return _storage._noInflightUpdates}
    set {_uniqueStorage()._noInflightUpdates = newValue}
  }

  ///
  ///The largest payment split that should be attempted when making a payment if
  ///splitting is necessary. Setting this value will effectively cause lnd to
  ///split more aggressively, vs only when it thinks it needs to. Note that this
  ///value is in milli-satoshis.
  var maxShardSizeMsat: UInt64 {
    get {return _storage._maxShardSizeMsat}
    set {_uniqueStorage()._maxShardSizeMsat = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Routerrpc_TrackPaymentRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The hash of the payment to look up.
  var paymentHash: Data = Data()

  ///
  ///If set, only the final payment update is streamed back. Intermediate updates
  ///that show which htlcs are still in flight are suppressed.
  var noInflightUpdates: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_RouteFeeRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The destination once wishes to obtain a routing fee quote to.
  var dest: Data = Data()

  ///
  ///The amount one wishes to send to the target destination.
  var amtSat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_RouteFeeResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///A lower bound of the estimated fee to the target destination within the
  ///network, expressed in milli-satoshis.
  var routingFeeMsat: Int64 = 0

  ///
  ///An estimate of the worst case time delay that can occur. Note that callers
  ///will still need to factor in the final CLTV delta of the last hop into this
  ///value.
  var timeLockDelay: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_SendToRouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The payment hash to use for the HTLC.
  var paymentHash: Data = Data()

  /// Route that should be used to attempt to complete the payment.
  var route: Lnrpc_Route {
    get {return _route ?? Lnrpc_Route()}
    set {_route = newValue}
  }
  /// Returns true if `route` has been explicitly set.
  var hasRoute: Bool {return self._route != nil}
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  mutating func clearRoute() {self._route = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _route: Lnrpc_Route? = nil
}

struct Routerrpc_SendToRouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The preimage obtained by making the payment.
  var preimage: Data = Data()

  /// The failure message in case the payment failed.
  var failure: Lnrpc_Failure {
    get {return _failure ?? Lnrpc_Failure()}
    set {_failure = newValue}
  }
  /// Returns true if `failure` has been explicitly set.
  var hasFailure: Bool {return self._failure != nil}
  /// Clears the value of `failure`. Subsequent reads from it will return its default value.
  mutating func clearFailure() {self._failure = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _failure: Lnrpc_Failure? = nil
}

struct Routerrpc_ResetMissionControlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_ResetMissionControlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_QueryMissionControlRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// QueryMissionControlResponse contains mission control state.
struct Routerrpc_QueryMissionControlResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Node pair-level mission control state.
  var pairs: [Routerrpc_PairHistory] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PairHistory contains the mission control state for a particular node pair.
struct Routerrpc_PairHistory {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The source node pubkey of the pair.
  var nodeFrom: Data = Data()

  /// The destination node pubkey of the pair.
  var nodeTo: Data = Data()

  var history: Routerrpc_PairData {
    get {return _history ?? Routerrpc_PairData()}
    set {_history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  var hasHistory: Bool {return self._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  mutating func clearHistory() {self._history = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _history: Routerrpc_PairData? = nil
}

struct Routerrpc_PairData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Time of last failure.
  var failTime: Int64 = 0

  ///
  ///Lowest amount that failed to forward rounded to whole sats. This may be
  ///set to zero if the failure is independent of amount.
  var failAmtSat: Int64 = 0

  ///
  ///Lowest amount that failed to forward in millisats. This may be
  ///set to zero if the failure is independent of amount.
  var failAmtMsat: Int64 = 0

  /// Time of last success.
  var successTime: Int64 = 0

  /// Highest amount that we could successfully forward rounded to whole sats.
  var successAmtSat: Int64 = 0

  /// Highest amount that we could successfully forward in millisats.
  var successAmtMsat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_QueryProbabilityRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The source node pubkey of the pair.
  var fromNode: Data = Data()

  /// The destination node pubkey of the pair.
  var toNode: Data = Data()

  /// The amount for which to calculate a probability.
  var amtMsat: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_QueryProbabilityResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The success probability for the requested pair.
  var probability: Double = 0

  /// The historical data for the requested pair.
  var history: Routerrpc_PairData {
    get {return _history ?? Routerrpc_PairData()}
    set {_history = newValue}
  }
  /// Returns true if `history` has been explicitly set.
  var hasHistory: Bool {return self._history != nil}
  /// Clears the value of `history`. Subsequent reads from it will return its default value.
  mutating func clearHistory() {self._history = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _history: Routerrpc_PairData? = nil
}

struct Routerrpc_BuildRouteRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The amount to send expressed in msat. If set to zero, the minimum routable
  ///amount is used.
  var amtMsat: Int64 = 0

  ///
  ///CLTV delta from the current height that should be used for the timelock
  ///of the final hop
  var finalCltvDelta: Int32 = 0

  ///
  ///The channel id of the channel that must be taken to the first hop. If zero,
  ///any channel may be used.
  var outgoingChanID: UInt64 = 0

  ///
  ///A list of hops that defines the route. This does not include the source hop
  ///pubkey.
  var hopPubkeys: [Data] = []

  /// An optional payment addr to be included within the last hop of the route.
  var paymentAddr: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_BuildRouteResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///Fully specified route that can be used to execute the payment.
  var route: Lnrpc_Route {
    get {return _route ?? Lnrpc_Route()}
    set {_route = newValue}
  }
  /// Returns true if `route` has been explicitly set.
  var hasRoute: Bool {return self._route != nil}
  /// Clears the value of `route`. Subsequent reads from it will return its default value.
  mutating func clearRoute() {self._route = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _route: Lnrpc_Route? = nil
}

struct Routerrpc_SubscribeHtlcEventsRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
///HtlcEvent contains the htlc event that was processed. These are served on a
///best-effort basis; events are not persisted, delivery is not guaranteed
///(in the event of a crash in the switch, forward events may be lost) and
///some events may be replayed upon restart. Events consumed from this package
///should be de-duplicated by the htlc's unique combination of incoming and
///outgoing channel id and htlc id. [EXPERIMENTAL]
struct Routerrpc_HtlcEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The short channel id that the incoming htlc arrived at our node on. This
  ///value is zero for sends.
  var incomingChannelID: UInt64 = 0

  ///
  ///The short channel id that the outgoing htlc left our node on. This value
  ///is zero for receives.
  var outgoingChannelID: UInt64 = 0

  ///
  ///Incoming id is the index of the incoming htlc in the incoming channel.
  ///This value is zero for sends.
  var incomingHtlcID: UInt64 = 0

  ///
  ///Outgoing id is the index of the outgoing htlc in the outgoing channel.
  ///This value is zero for receives.
  var outgoingHtlcID: UInt64 = 0

  ///
  ///The time in unix nanoseconds that the event occurred.
  var timestampNs: UInt64 = 0

  ///
  ///The event type indicates whether the htlc was part of a send, receive or
  ///forward.
  var eventType: Routerrpc_HtlcEvent.EventType = .unknown

  var event: Routerrpc_HtlcEvent.OneOf_Event? = nil

  var forwardEvent: Routerrpc_ForwardEvent {
    get {
      if case .forwardEvent(let v)? = event {return v}
      return Routerrpc_ForwardEvent()
    }
    set {event = .forwardEvent(newValue)}
  }

  var forwardFailEvent: Routerrpc_ForwardFailEvent {
    get {
      if case .forwardFailEvent(let v)? = event {return v}
      return Routerrpc_ForwardFailEvent()
    }
    set {event = .forwardFailEvent(newValue)}
  }

  var settleEvent: Routerrpc_SettleEvent {
    get {
      if case .settleEvent(let v)? = event {return v}
      return Routerrpc_SettleEvent()
    }
    set {event = .settleEvent(newValue)}
  }

  var linkFailEvent: Routerrpc_LinkFailEvent {
    get {
      if case .linkFailEvent(let v)? = event {return v}
      return Routerrpc_LinkFailEvent()
    }
    set {event = .linkFailEvent(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Event: Equatable {
    case forwardEvent(Routerrpc_ForwardEvent)
    case forwardFailEvent(Routerrpc_ForwardFailEvent)
    case settleEvent(Routerrpc_SettleEvent)
    case linkFailEvent(Routerrpc_LinkFailEvent)

  #if !swift(>=4.1)
    static func ==(lhs: Routerrpc_HtlcEvent.OneOf_Event, rhs: Routerrpc_HtlcEvent.OneOf_Event) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.forwardEvent, .forwardEvent): return {
        guard case .forwardEvent(let l) = lhs, case .forwardEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.forwardFailEvent, .forwardFailEvent): return {
        guard case .forwardFailEvent(let l) = lhs, case .forwardFailEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.settleEvent, .settleEvent): return {
        guard case .settleEvent(let l) = lhs, case .settleEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.linkFailEvent, .linkFailEvent): return {
        guard case .linkFailEvent(let l) = lhs, case .linkFailEvent(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  enum EventType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case unknown // = 0
    case send // = 1
    case receive // = 2
    case forward // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .unknown
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .unknown
      case 1: self = .send
      case 2: self = .receive
      case 3: self = .forward
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .unknown: return 0
      case .send: return 1
      case .receive: return 2
      case .forward: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Routerrpc_HtlcEvent.EventType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Routerrpc_HtlcEvent.EventType] = [
    .unknown,
    .send,
    .receive,
    .forward,
  ]
}

#endif  // swift(>=4.2)

struct Routerrpc_HtlcInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The timelock on the incoming htlc.
  var incomingTimelock: UInt32 = 0

  /// The timelock on the outgoing htlc.
  var outgoingTimelock: UInt32 = 0

  /// The amount of the incoming htlc.
  var incomingAmtMsat: UInt64 = 0

  /// The amount of the outgoing htlc.
  var outgoingAmtMsat: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_ForwardEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Info contains details about the htlc that was forwarded.
  var info: Routerrpc_HtlcInfo {
    get {return _info ?? Routerrpc_HtlcInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Routerrpc_HtlcInfo? = nil
}

struct Routerrpc_ForwardFailEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_SettleEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_LinkFailEvent {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Info contains details about the htlc that we failed.
  var info: Routerrpc_HtlcInfo {
    get {return _info ?? Routerrpc_HtlcInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  /// FailureCode is the BOLT error code for the failure.
  var wireFailure: Lnrpc_Failure.FailureCode = .reserved

  ///
  ///FailureDetail provides additional information about the reason for the
  ///failure. This detail enriches the information provided by the wire message
  ///and may be 'no detail' if the wire message requires no additional metadata.
  var failureDetail: Routerrpc_FailureDetail = .unknown

  /// A string representation of the link failure.
  var failureString: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Routerrpc_HtlcInfo? = nil
}

struct Routerrpc_PaymentStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Current state the payment is in.
  var state: Routerrpc_PaymentState = .inFlight

  ///
  ///The pre-image of the payment when state is SUCCEEDED.
  var preimage: Data = Data()

  ///
  ///The HTLCs made in attempt to settle the payment [EXPERIMENTAL].
  var htlcs: [Lnrpc_HTLCAttempt] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_CircuitKey {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// The id of the channel that the is part of this circuit.
  var chanID: UInt64 = 0

  //// The index of the incoming htlc in the incoming channel.
  var htlcID: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Routerrpc_ForwardHtlcInterceptRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///
  ///The key of this forwarded htlc. It defines the incoming channel id and
  ///the index in this channel.
  var incomingCircuitKey: Routerrpc_CircuitKey {
    get {return _incomingCircuitKey ?? Routerrpc_CircuitKey()}
    set {_incomingCircuitKey = newValue}
  }
  /// Returns true if `incomingCircuitKey` has been explicitly set.
  var hasIncomingCircuitKey: Bool {return self._incomingCircuitKey != nil}
  /// Clears the value of `incomingCircuitKey`. Subsequent reads from it will return its default value.
  mutating func clearIncomingCircuitKey() {self._incomingCircuitKey = nil}

  /// The incoming htlc amount.
  var incomingAmountMsat: UInt64 = 0

  /// The incoming htlc expiry.
  var incomingExpiry: UInt32 = 0

  ///
  ///The htlc payment hash. This value is not guaranteed to be unique per
  ///request.
  var paymentHash: Data = Data()

  /// The requested outgoing channel id for this forwarded htlc. Because of
  /// non-strict forwarding, this isn't necessarily the channel over which the
  /// packet will be forwarded eventually. A different channel to the same peer
  /// may be selected as well.
  var outgoingRequestedChanID: UInt64 = 0

  /// The outgoing htlc amount.
  var outgoingAmountMsat: UInt64 = 0

  /// The outgoing htlc expiry.
  var outgoingExpiry: UInt32 = 0

  /// Any custom records that were present in the payload.
  var customRecords: Dictionary<UInt64,Data> = [:]

  /// The onion blob for the next hop
  var onionBlob: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _incomingCircuitKey: Routerrpc_CircuitKey? = nil
}

///*
///ForwardHtlcInterceptResponse enables the caller to resolve a previously hold
///forward. The caller can choose either to:
///- `Resume`: Execute the default behavior (usually forward).
///- `Reject`: Fail the htlc backwards.
///- `Settle`: Settle this htlc with a given preimage.
struct Routerrpc_ForwardHtlcInterceptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///*
  ///The key of this forwarded htlc. It defines the incoming channel id and
  ///the index in this channel.
  var incomingCircuitKey: Routerrpc_CircuitKey {
    get {return _incomingCircuitKey ?? Routerrpc_CircuitKey()}
    set {_incomingCircuitKey = newValue}
  }
  /// Returns true if `incomingCircuitKey` has been explicitly set.
  var hasIncomingCircuitKey: Bool {return self._incomingCircuitKey != nil}
  /// Clears the value of `incomingCircuitKey`. Subsequent reads from it will return its default value.
  mutating func clearIncomingCircuitKey() {self._incomingCircuitKey = nil}

  /// The resolve action for this intercepted htlc.
  var action: Routerrpc_ResolveHoldForwardAction = .settle

  /// The preimage in case the resolve action is Settle.
  var preimage: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _incomingCircuitKey: Routerrpc_CircuitKey? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "routerrpc"

extension Routerrpc_FailureDetail: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "NO_DETAIL"),
    2: .same(proto: "ONION_DECODE"),
    3: .same(proto: "LINK_NOT_ELIGIBLE"),
    4: .same(proto: "ON_CHAIN_TIMEOUT"),
    5: .same(proto: "HTLC_EXCEEDS_MAX"),
    6: .same(proto: "INSUFFICIENT_BALANCE"),
    7: .same(proto: "INCOMPLETE_FORWARD"),
    8: .same(proto: "HTLC_ADD_FAILED"),
    9: .same(proto: "FORWARDS_DISABLED"),
    10: .same(proto: "INVOICE_CANCELED"),
    11: .same(proto: "INVOICE_UNDERPAID"),
    12: .same(proto: "INVOICE_EXPIRY_TOO_SOON"),
    13: .same(proto: "INVOICE_NOT_OPEN"),
    14: .same(proto: "MPP_INVOICE_TIMEOUT"),
    15: .same(proto: "ADDRESS_MISMATCH"),
    16: .same(proto: "SET_TOTAL_MISMATCH"),
    17: .same(proto: "SET_TOTAL_TOO_LOW"),
    18: .same(proto: "SET_OVERPAID"),
    19: .same(proto: "UNKNOWN_INVOICE"),
    20: .same(proto: "INVALID_KEYSEND"),
    21: .same(proto: "MPP_IN_PROGRESS"),
    22: .same(proto: "CIRCULAR_ROUTE"),
  ]
}

extension Routerrpc_PaymentState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IN_FLIGHT"),
    1: .same(proto: "SUCCEEDED"),
    2: .same(proto: "FAILED_TIMEOUT"),
    3: .same(proto: "FAILED_NO_ROUTE"),
    4: .same(proto: "FAILED_ERROR"),
    5: .same(proto: "FAILED_INCORRECT_PAYMENT_DETAILS"),
    6: .same(proto: "FAILED_INSUFFICIENT_BALANCE"),
  ]
}

extension Routerrpc_ResolveHoldForwardAction: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SETTLE"),
    1: .same(proto: "FAIL"),
    2: .same(proto: "RESUME"),
  ]
}

extension Routerrpc_SendPaymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendPaymentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dest"),
    2: .same(proto: "amt"),
    12: .standard(proto: "amt_msat"),
    3: .standard(proto: "payment_hash"),
    4: .standard(proto: "final_cltv_delta"),
    20: .standard(proto: "payment_addr"),
    5: .standard(proto: "payment_request"),
    6: .standard(proto: "timeout_seconds"),
    7: .standard(proto: "fee_limit_sat"),
    13: .standard(proto: "fee_limit_msat"),
    8: .standard(proto: "outgoing_chan_id"),
    19: .standard(proto: "outgoing_chan_ids"),
    14: .standard(proto: "last_hop_pubkey"),
    9: .standard(proto: "cltv_limit"),
    10: .standard(proto: "route_hints"),
    11: .standard(proto: "dest_custom_records"),
    15: .standard(proto: "allow_self_payment"),
    16: .standard(proto: "dest_features"),
    17: .standard(proto: "max_parts"),
    18: .standard(proto: "no_inflight_updates"),
    21: .standard(proto: "max_shard_size_msat"),
  ]

  fileprivate class _StorageClass {
    var _dest: Data = Data()
    var _amt: Int64 = 0
    var _amtMsat: Int64 = 0
    var _paymentHash: Data = Data()
    var _finalCltvDelta: Int32 = 0
    var _paymentAddr: Data = Data()
    var _paymentRequest: String = String()
    var _timeoutSeconds: Int32 = 0
    var _feeLimitSat: Int64 = 0
    var _feeLimitMsat: Int64 = 0
    var _outgoingChanID: UInt64 = 0
    var _outgoingChanIds: [UInt64] = []
    var _lastHopPubkey: Data = Data()
    var _cltvLimit: Int32 = 0
    var _routeHints: [Lnrpc_RouteHint] = []
    var _destCustomRecords: Dictionary<UInt64,Data> = [:]
    var _allowSelfPayment: Bool = false
    var _destFeatures: [Lnrpc_FeatureBit] = []
    var _maxParts: UInt32 = 0
    var _noInflightUpdates: Bool = false
    var _maxShardSizeMsat: UInt64 = 0

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _dest = source._dest
      _amt = source._amt
      _amtMsat = source._amtMsat
      _paymentHash = source._paymentHash
      _finalCltvDelta = source._finalCltvDelta
      _paymentAddr = source._paymentAddr
      _paymentRequest = source._paymentRequest
      _timeoutSeconds = source._timeoutSeconds
      _feeLimitSat = source._feeLimitSat
      _feeLimitMsat = source._feeLimitMsat
      _outgoingChanID = source._outgoingChanID
      _outgoingChanIds = source._outgoingChanIds
      _lastHopPubkey = source._lastHopPubkey
      _cltvLimit = source._cltvLimit
      _routeHints = source._routeHints
      _destCustomRecords = source._destCustomRecords
      _allowSelfPayment = source._allowSelfPayment
      _destFeatures = source._destFeatures
      _maxParts = source._maxParts
      _noInflightUpdates = source._noInflightUpdates
      _maxShardSizeMsat = source._maxShardSizeMsat
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBytesField(value: &_storage._dest) }()
        case 2: try { try decoder.decodeSingularInt64Field(value: &_storage._amt) }()
        case 3: try { try decoder.decodeSingularBytesField(value: &_storage._paymentHash) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._finalCltvDelta) }()
        case 5: try { try decoder.decodeSingularStringField(value: &_storage._paymentRequest) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._timeoutSeconds) }()
        case 7: try { try decoder.decodeSingularInt64Field(value: &_storage._feeLimitSat) }()
        case 8: try { try decoder.decodeSingularUInt64Field(value: &_storage._outgoingChanID) }()
        case 9: try { try decoder.decodeSingularInt32Field(value: &_storage._cltvLimit) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._routeHints) }()
        case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: &_storage._destCustomRecords) }()
        case 12: try { try decoder.decodeSingularInt64Field(value: &_storage._amtMsat) }()
        case 13: try { try decoder.decodeSingularInt64Field(value: &_storage._feeLimitMsat) }()
        case 14: try { try decoder.decodeSingularBytesField(value: &_storage._lastHopPubkey) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._allowSelfPayment) }()
        case 16: try { try decoder.decodeRepeatedEnumField(value: &_storage._destFeatures) }()
        case 17: try { try decoder.decodeSingularUInt32Field(value: &_storage._maxParts) }()
        case 18: try { try decoder.decodeSingularBoolField(value: &_storage._noInflightUpdates) }()
        case 19: try { try decoder.decodeRepeatedUInt64Field(value: &_storage._outgoingChanIds) }()
        case 20: try { try decoder.decodeSingularBytesField(value: &_storage._paymentAddr) }()
        case 21: try { try decoder.decodeSingularUInt64Field(value: &_storage._maxShardSizeMsat) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._dest.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._dest, fieldNumber: 1)
      }
      if _storage._amt != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amt, fieldNumber: 2)
      }
      if !_storage._paymentHash.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._paymentHash, fieldNumber: 3)
      }
      if _storage._finalCltvDelta != 0 {
        try visitor.visitSingularInt32Field(value: _storage._finalCltvDelta, fieldNumber: 4)
      }
      if !_storage._paymentRequest.isEmpty {
        try visitor.visitSingularStringField(value: _storage._paymentRequest, fieldNumber: 5)
      }
      if _storage._timeoutSeconds != 0 {
        try visitor.visitSingularInt32Field(value: _storage._timeoutSeconds, fieldNumber: 6)
      }
      if _storage._feeLimitSat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._feeLimitSat, fieldNumber: 7)
      }
      if _storage._outgoingChanID != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._outgoingChanID, fieldNumber: 8)
      }
      if _storage._cltvLimit != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cltvLimit, fieldNumber: 9)
      }
      if !_storage._routeHints.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._routeHints, fieldNumber: 10)
      }
      if !_storage._destCustomRecords.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: _storage._destCustomRecords, fieldNumber: 11)
      }
      if _storage._amtMsat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._amtMsat, fieldNumber: 12)
      }
      if _storage._feeLimitMsat != 0 {
        try visitor.visitSingularInt64Field(value: _storage._feeLimitMsat, fieldNumber: 13)
      }
      if !_storage._lastHopPubkey.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._lastHopPubkey, fieldNumber: 14)
      }
      if _storage._allowSelfPayment != false {
        try visitor.visitSingularBoolField(value: _storage._allowSelfPayment, fieldNumber: 15)
      }
      if !_storage._destFeatures.isEmpty {
        try visitor.visitPackedEnumField(value: _storage._destFeatures, fieldNumber: 16)
      }
      if _storage._maxParts != 0 {
        try visitor.visitSingularUInt32Field(value: _storage._maxParts, fieldNumber: 17)
      }
      if _storage._noInflightUpdates != false {
        try visitor.visitSingularBoolField(value: _storage._noInflightUpdates, fieldNumber: 18)
      }
      if !_storage._outgoingChanIds.isEmpty {
        try visitor.visitPackedUInt64Field(value: _storage._outgoingChanIds, fieldNumber: 19)
      }
      if !_storage._paymentAddr.isEmpty {
        try visitor.visitSingularBytesField(value: _storage._paymentAddr, fieldNumber: 20)
      }
      if _storage._maxShardSizeMsat != 0 {
        try visitor.visitSingularUInt64Field(value: _storage._maxShardSizeMsat, fieldNumber: 21)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_SendPaymentRequest, rhs: Routerrpc_SendPaymentRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dest != rhs_storage._dest {return false}
        if _storage._amt != rhs_storage._amt {return false}
        if _storage._amtMsat != rhs_storage._amtMsat {return false}
        if _storage._paymentHash != rhs_storage._paymentHash {return false}
        if _storage._finalCltvDelta != rhs_storage._finalCltvDelta {return false}
        if _storage._paymentAddr != rhs_storage._paymentAddr {return false}
        if _storage._paymentRequest != rhs_storage._paymentRequest {return false}
        if _storage._timeoutSeconds != rhs_storage._timeoutSeconds {return false}
        if _storage._feeLimitSat != rhs_storage._feeLimitSat {return false}
        if _storage._feeLimitMsat != rhs_storage._feeLimitMsat {return false}
        if _storage._outgoingChanID != rhs_storage._outgoingChanID {return false}
        if _storage._outgoingChanIds != rhs_storage._outgoingChanIds {return false}
        if _storage._lastHopPubkey != rhs_storage._lastHopPubkey {return false}
        if _storage._cltvLimit != rhs_storage._cltvLimit {return false}
        if _storage._routeHints != rhs_storage._routeHints {return false}
        if _storage._destCustomRecords != rhs_storage._destCustomRecords {return false}
        if _storage._allowSelfPayment != rhs_storage._allowSelfPayment {return false}
        if _storage._destFeatures != rhs_storage._destFeatures {return false}
        if _storage._maxParts != rhs_storage._maxParts {return false}
        if _storage._noInflightUpdates != rhs_storage._noInflightUpdates {return false}
        if _storage._maxShardSizeMsat != rhs_storage._maxShardSizeMsat {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_TrackPaymentRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TrackPaymentRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_hash"),
    2: .standard(proto: "no_inflight_updates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.noInflightUpdates) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 1)
    }
    if self.noInflightUpdates != false {
      try visitor.visitSingularBoolField(value: self.noInflightUpdates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_TrackPaymentRequest, rhs: Routerrpc_TrackPaymentRequest) -> Bool {
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.noInflightUpdates != rhs.noInflightUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_RouteFeeRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteFeeRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "dest"),
    2: .standard(proto: "amt_sat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.dest) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.amtSat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dest.isEmpty {
      try visitor.visitSingularBytesField(value: self.dest, fieldNumber: 1)
    }
    if self.amtSat != 0 {
      try visitor.visitSingularInt64Field(value: self.amtSat, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_RouteFeeRequest, rhs: Routerrpc_RouteFeeRequest) -> Bool {
    if lhs.dest != rhs.dest {return false}
    if lhs.amtSat != rhs.amtSat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_RouteFeeResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RouteFeeResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "routing_fee_msat"),
    2: .standard(proto: "time_lock_delay"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.routingFeeMsat) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.timeLockDelay) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.routingFeeMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.routingFeeMsat, fieldNumber: 1)
    }
    if self.timeLockDelay != 0 {
      try visitor.visitSingularInt64Field(value: self.timeLockDelay, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_RouteFeeResponse, rhs: Routerrpc_RouteFeeResponse) -> Bool {
    if lhs.routingFeeMsat != rhs.routingFeeMsat {return false}
    if lhs.timeLockDelay != rhs.timeLockDelay {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_SendToRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendToRouteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "payment_hash"),
    2: .same(proto: "route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._route) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 1)
    }
    if let v = self._route {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_SendToRouteRequest, rhs: Routerrpc_SendToRouteRequest) -> Bool {
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs._route != rhs._route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_SendToRouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendToRouteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "preimage"),
    2: .same(proto: "failure"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.preimage) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._failure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.preimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.preimage, fieldNumber: 1)
    }
    if let v = self._failure {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_SendToRouteResponse, rhs: Routerrpc_SendToRouteResponse) -> Bool {
    if lhs.preimage != rhs.preimage {return false}
    if lhs._failure != rhs._failure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_ResetMissionControlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetMissionControlRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_ResetMissionControlRequest, rhs: Routerrpc_ResetMissionControlRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_ResetMissionControlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ResetMissionControlResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_ResetMissionControlResponse, rhs: Routerrpc_ResetMissionControlResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_QueryMissionControlRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMissionControlRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_QueryMissionControlRequest, rhs: Routerrpc_QueryMissionControlRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_QueryMissionControlResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryMissionControlResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .same(proto: "pairs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.pairs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pairs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.pairs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_QueryMissionControlResponse, rhs: Routerrpc_QueryMissionControlResponse) -> Bool {
    if lhs.pairs != rhs.pairs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_PairHistory: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairHistory"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "node_from"),
    2: .standard(proto: "node_to"),
    7: .same(proto: "history"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.nodeFrom) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.nodeTo) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._history) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.nodeFrom.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeFrom, fieldNumber: 1)
    }
    if !self.nodeTo.isEmpty {
      try visitor.visitSingularBytesField(value: self.nodeTo, fieldNumber: 2)
    }
    if let v = self._history {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_PairHistory, rhs: Routerrpc_PairHistory) -> Bool {
    if lhs.nodeFrom != rhs.nodeFrom {return false}
    if lhs.nodeTo != rhs.nodeTo {return false}
    if lhs._history != rhs._history {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_PairData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fail_time"),
    2: .standard(proto: "fail_amt_sat"),
    4: .standard(proto: "fail_amt_msat"),
    5: .standard(proto: "success_time"),
    6: .standard(proto: "success_amt_sat"),
    7: .standard(proto: "success_amt_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.failTime) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.failAmtSat) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.failAmtMsat) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.successTime) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.successAmtSat) }()
      case 7: try { try decoder.decodeSingularInt64Field(value: &self.successAmtMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.failTime != 0 {
      try visitor.visitSingularInt64Field(value: self.failTime, fieldNumber: 1)
    }
    if self.failAmtSat != 0 {
      try visitor.visitSingularInt64Field(value: self.failAmtSat, fieldNumber: 2)
    }
    if self.failAmtMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.failAmtMsat, fieldNumber: 4)
    }
    if self.successTime != 0 {
      try visitor.visitSingularInt64Field(value: self.successTime, fieldNumber: 5)
    }
    if self.successAmtSat != 0 {
      try visitor.visitSingularInt64Field(value: self.successAmtSat, fieldNumber: 6)
    }
    if self.successAmtMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.successAmtMsat, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_PairData, rhs: Routerrpc_PairData) -> Bool {
    if lhs.failTime != rhs.failTime {return false}
    if lhs.failAmtSat != rhs.failAmtSat {return false}
    if lhs.failAmtMsat != rhs.failAmtMsat {return false}
    if lhs.successTime != rhs.successTime {return false}
    if lhs.successAmtSat != rhs.successAmtSat {return false}
    if lhs.successAmtMsat != rhs.successAmtMsat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_QueryProbabilityRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryProbabilityRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "from_node"),
    2: .standard(proto: "to_node"),
    3: .standard(proto: "amt_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.fromNode) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.toNode) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.amtMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fromNode.isEmpty {
      try visitor.visitSingularBytesField(value: self.fromNode, fieldNumber: 1)
    }
    if !self.toNode.isEmpty {
      try visitor.visitSingularBytesField(value: self.toNode, fieldNumber: 2)
    }
    if self.amtMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.amtMsat, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_QueryProbabilityRequest, rhs: Routerrpc_QueryProbabilityRequest) -> Bool {
    if lhs.fromNode != rhs.fromNode {return false}
    if lhs.toNode != rhs.toNode {return false}
    if lhs.amtMsat != rhs.amtMsat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_QueryProbabilityResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".QueryProbabilityResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "probability"),
    2: .same(proto: "history"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularDoubleField(value: &self.probability) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._history) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.probability != 0 {
      try visitor.visitSingularDoubleField(value: self.probability, fieldNumber: 1)
    }
    if let v = self._history {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_QueryProbabilityResponse, rhs: Routerrpc_QueryProbabilityResponse) -> Bool {
    if lhs.probability != rhs.probability {return false}
    if lhs._history != rhs._history {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_BuildRouteRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BuildRouteRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "amt_msat"),
    2: .standard(proto: "final_cltv_delta"),
    3: .standard(proto: "outgoing_chan_id"),
    4: .standard(proto: "hop_pubkeys"),
    5: .standard(proto: "payment_addr"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.amtMsat) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.finalCltvDelta) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.outgoingChanID) }()
      case 4: try { try decoder.decodeRepeatedBytesField(value: &self.hopPubkeys) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.paymentAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.amtMsat != 0 {
      try visitor.visitSingularInt64Field(value: self.amtMsat, fieldNumber: 1)
    }
    if self.finalCltvDelta != 0 {
      try visitor.visitSingularInt32Field(value: self.finalCltvDelta, fieldNumber: 2)
    }
    if self.outgoingChanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingChanID, fieldNumber: 3)
    }
    if !self.hopPubkeys.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.hopPubkeys, fieldNumber: 4)
    }
    if !self.paymentAddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentAddr, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_BuildRouteRequest, rhs: Routerrpc_BuildRouteRequest) -> Bool {
    if lhs.amtMsat != rhs.amtMsat {return false}
    if lhs.finalCltvDelta != rhs.finalCltvDelta {return false}
    if lhs.outgoingChanID != rhs.outgoingChanID {return false}
    if lhs.hopPubkeys != rhs.hopPubkeys {return false}
    if lhs.paymentAddr != rhs.paymentAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_BuildRouteResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BuildRouteResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "route"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._route) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._route {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_BuildRouteResponse, rhs: Routerrpc_BuildRouteResponse) -> Bool {
    if lhs._route != rhs._route {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_SubscribeHtlcEventsRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SubscribeHtlcEventsRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_SubscribeHtlcEventsRequest, rhs: Routerrpc_SubscribeHtlcEventsRequest) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_HtlcEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HtlcEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "incoming_channel_id"),
    2: .standard(proto: "outgoing_channel_id"),
    3: .standard(proto: "incoming_htlc_id"),
    4: .standard(proto: "outgoing_htlc_id"),
    5: .standard(proto: "timestamp_ns"),
    6: .standard(proto: "event_type"),
    7: .standard(proto: "forward_event"),
    8: .standard(proto: "forward_fail_event"),
    9: .standard(proto: "settle_event"),
    10: .standard(proto: "link_fail_event"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.incomingChannelID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.outgoingChannelID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.incomingHtlcID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.outgoingHtlcID) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.timestampNs) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.eventType) }()
      case 7: try {
        var v: Routerrpc_ForwardEvent?
        if let current = self.event {
          try decoder.handleConflictingOneOf()
          if case .forwardEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.event = .forwardEvent(v)}
      }()
      case 8: try {
        var v: Routerrpc_ForwardFailEvent?
        if let current = self.event {
          try decoder.handleConflictingOneOf()
          if case .forwardFailEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.event = .forwardFailEvent(v)}
      }()
      case 9: try {
        var v: Routerrpc_SettleEvent?
        if let current = self.event {
          try decoder.handleConflictingOneOf()
          if case .settleEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.event = .settleEvent(v)}
      }()
      case 10: try {
        var v: Routerrpc_LinkFailEvent?
        if let current = self.event {
          try decoder.handleConflictingOneOf()
          if case .linkFailEvent(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.event = .linkFailEvent(v)}
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.incomingChannelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.incomingChannelID, fieldNumber: 1)
    }
    if self.outgoingChannelID != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingChannelID, fieldNumber: 2)
    }
    if self.incomingHtlcID != 0 {
      try visitor.visitSingularUInt64Field(value: self.incomingHtlcID, fieldNumber: 3)
    }
    if self.outgoingHtlcID != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingHtlcID, fieldNumber: 4)
    }
    if self.timestampNs != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestampNs, fieldNumber: 5)
    }
    if self.eventType != .unknown {
      try visitor.visitSingularEnumField(value: self.eventType, fieldNumber: 6)
    }
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every case branch when no optimizations are
    // enabled. https://github.com/apple/swift-protobuf/issues/1034
    switch self.event {
    case .forwardEvent?: try {
      guard case .forwardEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .forwardFailEvent?: try {
      guard case .forwardFailEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .settleEvent?: try {
      guard case .settleEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .linkFailEvent?: try {
      guard case .linkFailEvent(let v)? = self.event else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_HtlcEvent, rhs: Routerrpc_HtlcEvent) -> Bool {
    if lhs.incomingChannelID != rhs.incomingChannelID {return false}
    if lhs.outgoingChannelID != rhs.outgoingChannelID {return false}
    if lhs.incomingHtlcID != rhs.incomingHtlcID {return false}
    if lhs.outgoingHtlcID != rhs.outgoingHtlcID {return false}
    if lhs.timestampNs != rhs.timestampNs {return false}
    if lhs.eventType != rhs.eventType {return false}
    if lhs.event != rhs.event {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_HtlcEvent.EventType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UNKNOWN"),
    1: .same(proto: "SEND"),
    2: .same(proto: "RECEIVE"),
    3: .same(proto: "FORWARD"),
  ]
}

extension Routerrpc_HtlcInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".HtlcInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "incoming_timelock"),
    2: .standard(proto: "outgoing_timelock"),
    3: .standard(proto: "incoming_amt_msat"),
    4: .standard(proto: "outgoing_amt_msat"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.incomingTimelock) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.outgoingTimelock) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.incomingAmtMsat) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.outgoingAmtMsat) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.incomingTimelock != 0 {
      try visitor.visitSingularUInt32Field(value: self.incomingTimelock, fieldNumber: 1)
    }
    if self.outgoingTimelock != 0 {
      try visitor.visitSingularUInt32Field(value: self.outgoingTimelock, fieldNumber: 2)
    }
    if self.incomingAmtMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.incomingAmtMsat, fieldNumber: 3)
    }
    if self.outgoingAmtMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingAmtMsat, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_HtlcInfo, rhs: Routerrpc_HtlcInfo) -> Bool {
    if lhs.incomingTimelock != rhs.incomingTimelock {return false}
    if lhs.outgoingTimelock != rhs.outgoingTimelock {return false}
    if lhs.incomingAmtMsat != rhs.incomingAmtMsat {return false}
    if lhs.outgoingAmtMsat != rhs.outgoingAmtMsat {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_ForwardEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_ForwardEvent, rhs: Routerrpc_ForwardEvent) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_ForwardFailEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardFailEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_ForwardFailEvent, rhs: Routerrpc_ForwardFailEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_SettleEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SettleEvent"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_SettleEvent, rhs: Routerrpc_SettleEvent) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_LinkFailEvent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LinkFailEvent"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
    2: .standard(proto: "wire_failure"),
    3: .standard(proto: "failure_detail"),
    4: .standard(proto: "failure_string"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.wireFailure) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.failureDetail) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.failureString) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.wireFailure != .reserved {
      try visitor.visitSingularEnumField(value: self.wireFailure, fieldNumber: 2)
    }
    if self.failureDetail != .unknown {
      try visitor.visitSingularEnumField(value: self.failureDetail, fieldNumber: 3)
    }
    if !self.failureString.isEmpty {
      try visitor.visitSingularStringField(value: self.failureString, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_LinkFailEvent, rhs: Routerrpc_LinkFailEvent) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.wireFailure != rhs.wireFailure {return false}
    if lhs.failureDetail != rhs.failureDetail {return false}
    if lhs.failureString != rhs.failureString {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_PaymentStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PaymentStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .same(proto: "preimage"),
    4: .same(proto: "htlcs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.state) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.preimage) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.htlcs) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.state != .inFlight {
      try visitor.visitSingularEnumField(value: self.state, fieldNumber: 1)
    }
    if !self.preimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.preimage, fieldNumber: 2)
    }
    if !self.htlcs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.htlcs, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_PaymentStatus, rhs: Routerrpc_PaymentStatus) -> Bool {
    if lhs.state != rhs.state {return false}
    if lhs.preimage != rhs.preimage {return false}
    if lhs.htlcs != rhs.htlcs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_CircuitKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CircuitKey"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chan_id"),
    2: .standard(proto: "htlc_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.chanID) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.htlcID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.chanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.chanID, fieldNumber: 1)
    }
    if self.htlcID != 0 {
      try visitor.visitSingularUInt64Field(value: self.htlcID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_CircuitKey, rhs: Routerrpc_CircuitKey) -> Bool {
    if lhs.chanID != rhs.chanID {return false}
    if lhs.htlcID != rhs.htlcID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_ForwardHtlcInterceptRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardHtlcInterceptRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "incoming_circuit_key"),
    5: .standard(proto: "incoming_amount_msat"),
    6: .standard(proto: "incoming_expiry"),
    2: .standard(proto: "payment_hash"),
    7: .standard(proto: "outgoing_requested_chan_id"),
    3: .standard(proto: "outgoing_amount_msat"),
    4: .standard(proto: "outgoing_expiry"),
    8: .standard(proto: "custom_records"),
    9: .standard(proto: "onion_blob"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._incomingCircuitKey) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.paymentHash) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.outgoingAmountMsat) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self.outgoingExpiry) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.incomingAmountMsat) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self.incomingExpiry) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.outgoingRequestedChanID) }()
      case 8: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: &self.customRecords) }()
      case 9: try { try decoder.decodeSingularBytesField(value: &self.onionBlob) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._incomingCircuitKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.paymentHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.paymentHash, fieldNumber: 2)
    }
    if self.outgoingAmountMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingAmountMsat, fieldNumber: 3)
    }
    if self.outgoingExpiry != 0 {
      try visitor.visitSingularUInt32Field(value: self.outgoingExpiry, fieldNumber: 4)
    }
    if self.incomingAmountMsat != 0 {
      try visitor.visitSingularUInt64Field(value: self.incomingAmountMsat, fieldNumber: 5)
    }
    if self.incomingExpiry != 0 {
      try visitor.visitSingularUInt32Field(value: self.incomingExpiry, fieldNumber: 6)
    }
    if self.outgoingRequestedChanID != 0 {
      try visitor.visitSingularUInt64Field(value: self.outgoingRequestedChanID, fieldNumber: 7)
    }
    if !self.customRecords.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufUInt64,SwiftProtobuf.ProtobufBytes>.self, value: self.customRecords, fieldNumber: 8)
    }
    if !self.onionBlob.isEmpty {
      try visitor.visitSingularBytesField(value: self.onionBlob, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_ForwardHtlcInterceptRequest, rhs: Routerrpc_ForwardHtlcInterceptRequest) -> Bool {
    if lhs._incomingCircuitKey != rhs._incomingCircuitKey {return false}
    if lhs.incomingAmountMsat != rhs.incomingAmountMsat {return false}
    if lhs.incomingExpiry != rhs.incomingExpiry {return false}
    if lhs.paymentHash != rhs.paymentHash {return false}
    if lhs.outgoingRequestedChanID != rhs.outgoingRequestedChanID {return false}
    if lhs.outgoingAmountMsat != rhs.outgoingAmountMsat {return false}
    if lhs.outgoingExpiry != rhs.outgoingExpiry {return false}
    if lhs.customRecords != rhs.customRecords {return false}
    if lhs.onionBlob != rhs.onionBlob {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Routerrpc_ForwardHtlcInterceptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ForwardHtlcInterceptResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "incoming_circuit_key"),
    2: .same(proto: "action"),
    3: .same(proto: "preimage"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._incomingCircuitKey) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.action) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.preimage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._incomingCircuitKey {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.action != .settle {
      try visitor.visitSingularEnumField(value: self.action, fieldNumber: 2)
    }
    if !self.preimage.isEmpty {
      try visitor.visitSingularBytesField(value: self.preimage, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Routerrpc_ForwardHtlcInterceptResponse, rhs: Routerrpc_ForwardHtlcInterceptResponse) -> Bool {
    if lhs._incomingCircuitKey != rhs._incomingCircuitKey {return false}
    if lhs.action != rhs.action {return false}
    if lhs.preimage != rhs.preimage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
